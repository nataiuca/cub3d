Cosas a hacer:

- cambiar estructura t_img por la t_img de la minilibx (+ adaptar cÃ³digo) (en el subject dice de usar images de la minilibx) âŒ
- aÃ±adir minimapa âŒ


PARSEO:
- creo que el parseo tiene que aceptar espacios entre los valores de los colores âœ… 
- el parseo tiene que aceptar lÃ­neas vacÃ­as entre las lÃ­neas de configuraciÃ³n âœ… 
- creo que no deberia aceptar lÃ­neas vacÃ­as dentro del mapa âœ… 
- cambiar mensajes de error -> sistematizados desde funciÃ³n msg_error + poner exit status (AHORA MISMO SIEMPRE SE SALE CON EXIT_FAILURE, DA IGUAL) 

raycasting:
- separar bien responsabilidades: el cÃ¡lculo de los rayos tiene que servir para el minimapa

08.10.25 - 17.30h includes y srcs
Esta versiÃ³n no compila
Tareas en marcha:
- parseo (directorio parsing):
* que acepte espacios y lÃ­neas entre las lÃ­neas de configuraciÃ³n de textura y colores y entre sus argumentos
* no tiene que aceptar lineas vacÃ­as dentro del mapa
* DÃ“NDE ESTAMOS: integrando parseo y validaciÃ³n del mapa (mÃ­a) con normalizaciÃ³n (de natalia) -> puntos crÃ­ticos: el spliteo de lÃ­neas que hago yo, que relleno os espacios de 0s... manejar! âœ… 
* Atenta! A inicializaciÃ³n del player y su orientaciÃ³n... adaptar parseo a la lÃ³gica
- cambio de mensajes error - EN PROCESO

Cosas que hay que hacer no empezadas:
- cambiar estructura t_img por la t_img de la minilibx
- No sÃ© si valdrÃ­a la pena cambiarse a la mlx42
- Entender el raycasting y separar bien responsabilidades: el cÃ¡lculo de los rayos tiene que servir para el minimapa


09.10.25 - 12h
Esta versiÃ³n compila pero no ejecuta grÃ¡ficos:
- normalizaciÃ³n de natalia + mi parseo de mapa y configuraciÃ³n, integrado âœ… 
Siguientes paso: 
- integrar bien inicializaciÃ³n de player y su orientaciÃ³n con su uso en grÃ¡ficos
- sustituir funciones de minilibx por MLX42 + sustituir t_img(es mÃ¡s fÃ¡cil y hay mucho manejo muy bajo y complicado de las imgs que creo que no hace falta; ademÃ¡s se pide en el subject el empleo de imgs de la minilibx)
- minimap: manejar la presencia de espacios

voy a ir poco a poco antes de displayear grÃ¡ficos


CÃ³mo convertir xpm a xpm42?: python3 ../MLX42/tools/xpm3_conv.py wall_south.xpm 


VALGRIND: 

valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes --verbose ./tu_programa

CÃ“MO SABER SI LOS LEAKS SON DE NUESTRO CÃ“DIGO O DE LA MLX42:

valgrind --leak-che ck=full --show-leak-kinds=all --track-origins=yes ./cub3D maps/map.cub 2> valgrind.log

-> Si la lÃ­nea menciona usr/lib/.. o libglfw, libX11, libGL, libpthread, libc... Son leaks del sistema o de MLX42
-> Preocuparse de frames que terminan en tu binario, 


13.10.25 - 14h
Revision del parseo: 

read_file.c â†’ lectura del archivo .cub
config_parser.c â†’ parseo de texturas y colores
map_parser.c â†’ parseo de la matriz del mapa
config_validator.c â†’ validaciones de texturas y colores
map_validator.c â†’ validaciones del mapa (cierre, caracteres, jugador)
parser_utils.c â†’ helpers (split, atoi, trim, check file)
âœ… Parseo correcto para cub3D.

Cumplimiento del subject
Mapas
Solo caracteres 0,1,N,S,E,W â†’ map_validator.c verifica caracteres vÃ¡lidos
Mapa cerrado â†’ map_validator.c incluye validaciÃ³n de bordes y adyacentes
Un solo jugador â†’ map_parser.c / validator cuentan el jugador
Espacios â†’ el parser respeta espacios dentro del mapa
LÃ­neas vacÃ­as fuera del mapa â†’ ignoradas correctamente
âœ… Cumple con todos los puntos de mapa.
Texturas
NO, SO, WE, EA â†’ extraÃ­dos por config_parser.c
Se debe comprobar que cada textura exista â†’ si config_parser.c llama a access() o similar, estÃ¡ correcto
No duplicados â†’ config_parser.c verifica si ya se asignÃ³ una textura
âœ… Cumple, si efectivamente se valida la existencia de archivos.
Colores F y C
Parseo de RGB â†’ config_parser.c / config_validator.c
ValidaciÃ³n de rango 0â€“255 â†’ estÃ¡ implementada en config_validator.c
Manejo de espacios extra â†’ con ft_split
âœ… Cumple, con la condiciÃ³n de que se validan nÃºmeros fuera de rango y caracteres invÃ¡lidos.
Manejo de errores
El subject exige "Error\n" + mensaje descriptivo
Se llama a la funciÃ³n error_exit(msg)
âœ… Se cumple.

He revisado con valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes --log-file=valgrind.log ./cub3D maps/map_good_3.cub
y free_sprite termina prematuramente, Esto hace que si un sprite es NULL en medio de la lista, se queden sprites sin liberar.
AdemÃ¡s, si este return se activa, algunos punteros de sprites quedan todavÃ­a en memoria y luego cleanup_game podrÃ­a intentar liberar algo de nuevo,
causando use-after-free.
mlx_delete_image sobre punteros posiblemente ya liberados:
En cleanup_game, se libera game-texture [i] y luego se llama a a mlx_terminate, despues se llama a 
free_sprite(game), que hace mlx_delete_image sobre los frames de los sprites. Si alguna de esas imagenes 
ya fue liberada por mlx_terminate o mlx_delete_image antes, valgrind marcara invalid read.
Falta NULL despues de liberar: 
despuÃ©s de free() y mlx_delete_image() no hay punteros a NULL, podrÃ­a haber double free o use-after-free.
Modificadas las funciones cleanup_game y free_sprite, se elimina return en free_sprite, se usa continue. 
Se ponen los punteros a NULL despuÃ©s de liberar y asegurar que nada se lea despuÃ©s de ser liberado. 
Los leaks que salen son de la MLX42.


14.10.25 12h
Revisados los mmovimientos del jugador, al chocar contra los muros, hay desplazamiento, se desliza por las parredes, este desplazamiento es el "sliding",
El sliding es una tÃ©cnica de movimiento que permite al jugador deslizarse suavemente a lo largo de obstÃ¡culos en lugar de quedarse completamente bloqueado 
cuando intenta moverse en diagonal hacia una esquina. Cuando el jugador intenta moverse en diagonal, puede ocurrir que:
La nueva posiciÃ³n completa (X + Y) estÃ¡ ocupada por una pared.
Pero la direcciÃ³n solo en X o solo en Y estÃ¡ libre.
ğŸ‘‰ En lugar de bloquear totalmente el movimiento, permitimos que el jugador se desplace parcialmente, generando una sensaciÃ³n mÃ¡s fluida y realista.
En nuestras funciones de movimiento (move_forward, move_backward, move_left y mode_right.), aplicamos la siguiente lÃ³gica:
if (valid(X + dx, Y + dy))
    mover completamente
else if (valid(X + dx, Y))
    mover solo en X
else if (valid(X, Y + dy))
    mover solo en Y
Esto permite:
Intentar moverse completamente.
Si no es posible, moverse en la direcciÃ³n libre.
Si ambas estÃ¡n bloqueadas, quedarse quieto.
Sin sliding, chocar contra una pared en diagonal frena completamente al jugador, incluso si una de las dos direcciones estÃ¡ libre. 
Esto genera un comportamiento tosco o poco natural.
Con sliding, el jugador resbala por la pared, permitiendo un movimiento mÃ¡s suave y menos frustrante.

14.10.25 14h

ImplementaciÃ³n de la rotaciÃ³n de la cÃ¡mara con el ratÃ³n:
Implementamos rotaciÃ³n de la cÃ¡mara con el ratÃ³n. Creamos una funciÃ³n que detecta el movimiento 
horizontal del cursor (xpos) y, si se mueve hacia la derecha o izquierda, actualiza la direcciÃ³n del jugador llamando a rotate_player(). 
AdemÃ¡s, centramos el ratÃ³n constantemente para evitar que llegue al borde de la ventana y poder seguir girando indefinidamente, como en los 
juegos en primera persona. Esta funciÃ³n se engancha con mlx_set_cursor_hook() de MLX42, y ocultamos el cursor con mlx_set_cursor_mode().
1. Detecta movimiento del ratÃ³n
MLX42 llama automÃ¡ticamente a handle_mouse_movement() cada vez que el ratÃ³n se mueve.
Recibe las coordenadas del ratÃ³n: xpos (horizontal) y ypos (vertical).
ğŸ”„ 2. Compara la posiciÃ³n actual con la anterior
delta_x = xpos - last_x calcula cuÃ¡nto se ha movido el ratÃ³n horizontalmente.
Un valor positivo significa que el ratÃ³n se moviÃ³ a la derecha, y negativo a la izquierda.
ğŸ” 3. Gira al jugador
Si el ratÃ³n se moviÃ³ a la derecha, se llama a rotate_player() con RIGHT.
Si se moviÃ³ a la izquierda, se llama con LEFT.
Esta funciÃ³n actualiza la direcciÃ³n (dir_x, dir_y) del jugador.
ğŸ¯ 4. Centra el ratÃ³n
Se llama a mlx_set_mouse_pos() para volver a poner el ratÃ³n en el centro de la ventana.
Esto permite que el usuario pueda seguir girando indefinidamente, sin que el ratÃ³n llegue a los bordes de la pantalla.

Norminette (14.10.25 15h)
src/controls/events.c
- falta el header

estÃ¡ todo revisado salvo minimap, sprite y el main



src/
â”‚
â”œâ”€â”€ controls/
â”‚   â”œâ”€â”€ events.c    // handle_keypress() y handle_close()
â”‚
â”œâ”€â”€ engines /
â”‚   â”œâ”€â”€ collision.c //check_corners(), is_valid_pos()
â”‚   â”œâ”€â”€ moves.c // rotate_player(), move_right(), move_left()...
â”‚   â””â”€â”€ player.c // update_player(), init_player_orientation()
â”‚   â””â”€â”€ raycasting.c //cast_all_rays(), calc_wall_dist(), perform_dda(), calc_step_dist(), init_ray()
â”‚
â”œâ”€â”€ graphics /
â”‚   â”œâ”€â”€ draw_3d.c //get_tex_color(), get_tex_index(), calc_tex_x(), draw_floor_ceiling(), draw_tex_wall(), draw_column(), draw_3d_view()
â”‚   â”œâ”€â”€ init_mlx.c//init_graphics.c(), load_textures(), load_texture()
â”‚
â”œâ”€â”€ minimap /
â”‚   â”œâ”€â”€ minimap_cast.c //cast_ray_minimap(), cast_all_rays_minimap(), draw_rays(), draw_line(), 
â”‚   â”œâ”€â”€ minimap_draw.c//draw_minimap(), draw_minimap_grid(), draw_player(), 
â”‚   â””â”€â”€ minimap_utils.c //init_minimap(), draw_square(), get_minimap_cell_color(), clear_minimap() 
â”‚  
â”œâ”€â”€ parsing /
â”‚   â”œâ”€â”€config_parser.c //parse_config(), handle_config_line(), extract_texture_path(), extract_color_raw()
â”‚   â”œâ”€â”€ config_validator.c//validate_config(), validate_texture_path(), validate_color_str(), validate_rgb_values(), rgb_to_int()
|   â”œâ”€â”€ map_parser.c//parse_map(), count_rows()
|   â”œâ”€â”€ map_validator.c//validate_map(), check_trailing_rows(), is_map_closed(), normalize_map(), process_map_line(), measure_map(), 
|   â”œâ”€â”€ parser_utils.c //skip_empty_lines(), is_map_start_line()
â”‚   â””â”€â”€ read_file.c //load_info(), read_file(), count_file_lines()
â”œâ”€â”€ utils /
â”‚   â”œâ”€â”€ cleanup.c //cleanup_game(), free_map(), free_info(), free_str_array()
â”‚   â””â”€â”€ error.c //error_msg(), error_exit(), error_cleanup_exit()
â””â”€â”€ main.c
â””â”€â”€ init_structs.c

