Cosas a hacer:

- cambiar estructura t_img por la t_img de la minilibx (+ adaptar código) (en el subject dice de usar images de la minilibx) ❌
- añadir minimapa ❌


PARSEO:
- creo que el parseo tiene que aceptar espacios entre los valores de los colores ✅ 
- el parseo tiene que aceptar líneas vacías entre las líneas de configuración ✅ 
- creo que no deberia aceptar líneas vacías dentro del mapa ✅ 
- cambiar mensajes de error -> sistematizados desde función msg_error + poner exit status (AHORA MISMO SIEMPRE SE SALE CON EXIT_FAILURE, DA IGUAL) 

raycasting:
- separar bien responsabilidades: el cálculo de los rayos tiene que servir para el minimapa

08.10.25 - 17.30h includes y srcs
Esta versión no compila
Tareas en marcha:
- parseo (directorio parsing):
* que acepte espacios y líneas entre las líneas de configuración de textura y colores y entre sus argumentos
* no tiene que aceptar lineas vacías dentro del mapa
* DÓNDE ESTAMOS: integrando parseo y validación del mapa (mía) con normalización (de natalia) -> puntos críticos: el spliteo de líneas que hago yo, que relleno os espacios de 0s... manejar! ✅ 
* Atenta! A inicialización del player y su orientación... adaptar parseo a la lógica
- cambio de mensajes error - EN PROCESO

Cosas que hay que hacer no empezadas:
- cambiar estructura t_img por la t_img de la minilibx
- No sé si valdría la pena cambiarse a la mlx42
- Entender el raycasting y separar bien responsabilidades: el cálculo de los rayos tiene que servir para el minimapa


09.10.25 - 12h
Esta versión compila pero no ejecuta gráficos:
- normalización de natalia + mi parseo de mapa y configuración, integrado ✅ 
Siguientes paso: 
- integrar bien inicialización de player y su orientación con su uso en gráficos
- sustituir funciones de minilibx por MLX42 + sustituir t_img(es más fácil y hay mucho manejo muy bajo y complicado de las imgs que creo que no hace falta; además se pide en el subject el empleo de imgs de la minilibx)
- minimap: manejar la presencia de espacios

voy a ir poco a poco antes de displayear gráficos


Cómo convertir xpm a xpm42?: python3 ../MLX42/tools/xpm3_conv.py wall_south.xpm 


VALGRIND: 

valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes --verbose ./tu_programa

CÓMO SABER SI LOS LEAKS SON DE NUESTRO CÓDIGO O DE LA MLX42:

valgrind --leak-che ck=full --show-leak-kinds=all --track-origins=yes ./cub3D maps/map.cub 2> valgrind.log

-> Si la línea menciona usr/lib/.. o libglfw, libX11, libGL, libpthread, libc... Son leaks del sistema o de MLX42
-> Preocuparse de frames que terminan en tu binario, 


13.10.25 - 14h
Revision del parseo: 

read_file.c → lectura del archivo .cub
config_parser.c → parseo de texturas y colores
map_parser.c → parseo de la matriz del mapa
config_validator.c → validaciones de texturas y colores
map_validator.c → validaciones del mapa (cierre, caracteres, jugador)
parser_utils.c → helpers (split, atoi, trim, check file)
✅ Parseo correcto para cub3D.

Cumplimiento del subject
Mapas
Solo caracteres 0,1,N,S,E,W → map_validator.c verifica caracteres válidos
Mapa cerrado → map_validator.c incluye validación de bordes y adyacentes
Un solo jugador → map_parser.c / validator cuentan el jugador
Espacios → el parser respeta espacios dentro del mapa
Líneas vacías fuera del mapa → ignoradas correctamente
✅ Cumple con todos los puntos de mapa.
Texturas
NO, SO, WE, EA → extraídos por config_parser.c
Se debe comprobar que cada textura exista → si config_parser.c llama a access() o similar, está correcto
No duplicados → config_parser.c verifica si ya se asignó una textura
✅ Cumple, si efectivamente se valida la existencia de archivos.
Colores F y C
Parseo de RGB → config_parser.c / config_validator.c
Validación de rango 0–255 → está implementada en config_validator.c
Manejo de espacios extra → con ft_split
✅ Cumple, con la condición de que se validan números fuera de rango y caracteres inválidos.
Manejo de errores
El subject exige "Error\n" + mensaje descriptivo
Se llama a la función error_exit(msg)
✅ Se cumple.

He revisado con valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes --log-file=valgrind.log ./cub3D maps/map_good_3.cub
y free_sprite termina prematuramente, Esto hace que si un sprite es NULL en medio de la lista, se queden sprites sin liberar.
Además, si este return se activa, algunos punteros de sprites quedan todavía en memoria y luego cleanup_game podría intentar liberar algo de nuevo,
causando use-after-free.
mlx_delete_image sobre punteros posiblemente ya liberados:
En cleanup_game, se libera game-texture [i] y luego se llama a a mlx_terminate, despues se llama a 
free_sprite(game), que hace mlx_delete_image sobre los frames de los sprites. Si alguna de esas imagenes 
ya fue liberada por mlx_terminate o mlx_delete_image antes, valgrind marcara invalid read.
Falta NULL despues de liberar: 
después de free() y mlx_delete_image() no hay punteros a NULL, podría haber double free o use-after-free.
Modificadas las funciones cleanup_game y free_sprite, se elimina return en free_sprite, se usa continue. 
Se ponen los punteros a NULL después de liberar y asegurar que nada se lea después de ser liberado. 
Los leaks que salen son de la MLX42.

Falta pasar Norminette


src/
│
├── controls/
│   ├── events.c    // handle_keypress() y handle_close()
│
├── engines /
│   ├── collision.c //check_corners(), is_valid_pos()
│   ├── moves.c // rotate_player(), move_right(), move_left()...
│   └── player.c // update_player(), init_player_orientation()
│   └── raycasting.c //cast_all_rays(), calc_wall_dist(), perform_dda(), calc_step_dist(), init_ray()
│
├── graphics /
│   ├── draw_3d.c //get_tex_color(), get_tex_index(), calc_tex_x(), draw_floor_ceiling(), draw_tex_wall(), draw_column(), draw_3d_view()
│   ├── init_mlx.c//init_graphics.c(), load_textures(), load_texture()
│
├── minimap /
│   ├── minimap_cast.c //cast_ray_minimap(), cast_all_rays_minimap(), draw_rays(), draw_line(), 
│   ├── minimap_draw.c//draw_minimap(), draw_minimap_grid(), draw_player(), 
│   └── minimap_utils.c //init_minimap(), draw_square(), get_minimap_cell_color(), clear_minimap() 
│  
├── parsing /
│   ├──config_parser.c //parse_config(), handle_config_line(), extract_texture_path(), extract_color_raw()
│   ├── config_validator.c//validate_config(), validate_texture_path(), validate_color_str(), validate_rgb_values(), rgb_to_int()
|   ├── map_parser.c//parse_map(), count_rows()
|   ├── map_validator.c//validate_map(), check_trailing_rows(), is_map_closed(), normalize_map(), process_map_line(), measure_map(), 
|   ├── parser_utils.c //skip_empty_lines(), is_map_start_line()
│   └── read_file.c //load_info(), read_file(), count_file_lines()
├── utils /
│   ├── cleanup.c //cleanup_game(), free_map(), free_info(), free_str_array()
│   └── error.c //error_msg(), error_exit(), error_cleanup_exit()
└── main.c
└── init_structs.c

