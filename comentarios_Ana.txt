Cosas a hacer:

- cambiar estructura t_img por la t_img de la minilibx (+ adaptar código) (en el subject dice de usar images de la minilibx) ❌
- añadir minimapa ❌


PARSEO:
- creo que el parseo tiene que aceptar espacios entre los valores de los colores ✅ 
- el parseo tiene que aceptar líneas vacías entre las líneas de configuración ✅ 
- creo que no deberia aceptar líneas vacías dentro del mapa ✅ 
- cambiar mensajes de error -> sistematizados desde función msg_error + poner exit status (AHORA MISMO SIEMPRE SE SALE CON EXIT_FAILURE, DA IGUAL) 

raycasting:
- separar bien responsabilidades: el cálculo de los rayos tiene que servir para el minimapa

08.10.25 - 17.30h includes y srcs
Esta versión no compila
Tareas en marcha:
- parseo (directorio parsing):
* que acepte espacios y líneas entre las líneas de configuración de textura y colores y entre sus argumentos
* no tiene que aceptar lineas vacías dentro del mapa
* DÓNDE ESTAMOS: integrando parseo y validación del mapa (mía) con normalización (de natalia) -> puntos críticos: el spliteo de líneas que hago yo, que relleno os espacios de 0s... manejar! ✅ 
* Atenta! A inicialización del player y su orientación... adaptar parseo a la lógica
- cambio de mensajes error - EN PROCESO

Cosas que hay que hacer no empezadas:
- cambiar estructura t_img por la t_img de la minilibx
- No sé si valdría la pena cambiarse a la mlx42
- Entender el raycasting y separar bien responsabilidades: el cálculo de los rayos tiene que servir para el minimapa


09.10.25 - 12h
Esta versión compila pero no ejecuta gráficos:
- normalización de natalia + mi parseo de mapa y configuración, integrado ✅ 
Siguientes paso: 
- integrar bien inicialización de player y su orientación con su uso en gráficos
- sustituir funciones de minilibx por MLX42 + sustituir t_img(es más fácil y hay mucho manejo muy bajo y complicado de las imgs que creo que no hace falta; además se pide en el subject el empleo de imgs de la minilibx)
- minimap: manejar la presencia de espacios

voy a ir poco a poco antes de displayear gráficos


Cómo convertir xpm a xpm42?: python3 ../MLX42/tools/xpm3_conv.py wall_south.xpm 


VALGRIND: 

valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes --verbose ./tu_programa

CÓMO SABER SI LOS LEAKS SON DE NUESTRO CÓDIGO O DE LA MLX42:

valgrind --leak-che ck=full --show-leak-kinds=all --track-origins=yes ./cub3D maps/map.cub 2> valgrind.log

-> Si la línea menciona usr/lib/.. o libglfw, libX11, libGL, libpthread, libc... Son leaks del sistema o de MLX42
-> Preocuparse de frames que terminan en tu binario, 


13.10.25 - 14h
Revision del parseo: 

read_file.c → lectura del archivo .cub
config_parser.c → parseo de texturas y colores
map_parser.c → parseo de la matriz del mapa
config_validator.c → validaciones de texturas y colores
map_validator.c → validaciones del mapa (cierre, caracteres, jugador)
parser_utils.c → helpers (split, atoi, trim, check file)
✅ Parseo correcto para cub3D.

Cumplimiento del subject
Mapas
Solo caracteres 0,1,N,S,E,W → map_validator.c verifica caracteres válidos
Mapa cerrado → map_validator.c incluye validación de bordes y adyacentes
Un solo jugador → map_parser.c / validator cuentan el jugador
Espacios → el parser respeta espacios dentro del mapa
Líneas vacías fuera del mapa → ignoradas correctamente
✅ Cumple con todos los puntos de mapa.
Texturas
NO, SO, WE, EA → extraídos por config_parser.c
Se debe comprobar que cada textura exista → si config_parser.c llama a access() o similar, está correcto
No duplicados → config_parser.c verifica si ya se asignó una textura
✅ Cumple, si efectivamente se valida la existencia de archivos.
Colores F y C
Parseo de RGB → config_parser.c / config_validator.c
Validación de rango 0–255 → está implementada en config_validator.c
Manejo de espacios extra → con ft_split
✅ Cumple, con la condición de que se validan números fuera de rango y caracteres inválidos.
Manejo de errores
El subject exige "Error\n" + mensaje descriptivo
Se llama a la función error_exit(msg)
✅ Se cumple.

He revisado con valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes --log-file=valgrind.log ./cub3D maps/map_good_3.cub
y free_sprite termina prematuramente, Esto hace que si un sprite es NULL en medio de la lista, se queden sprites sin liberar.
Además, si este return se activa, algunos punteros de sprites quedan todavía en memoria y luego cleanup_game podría intentar liberar algo de nuevo,
causando use-after-free.
mlx_delete_image sobre punteros posiblemente ya liberados:
En cleanup_game, se libera game-texture [i] y luego se llama a a mlx_terminate, despues se llama a 
free_sprite(game), que hace mlx_delete_image sobre los frames de los sprites. Si alguna de esas imagenes 
ya fue liberada por mlx_terminate o mlx_delete_image antes, valgrind marcara invalid read.
Falta NULL despues de liberar: 
después de free() y mlx_delete_image() no hay punteros a NULL, podría haber double free o use-after-free.
Modificadas las funciones cleanup_game y free_sprite, se elimina return en free_sprite, se usa continue. 
Se ponen los punteros a NULL después de liberar y asegurar que nada se lea después de ser liberado. 
Los leaks que salen son de la MLX42.


14.10.25 12h
Revisados los mmovimientos del jugador, al chocar contra los muros, hay desplazamiento, se desliza por las parredes, este desplazamiento es el "sliding",
El sliding es una técnica de movimiento que permite al jugador deslizarse suavemente a lo largo de obstáculos en lugar de quedarse completamente bloqueado 
cuando intenta moverse en diagonal hacia una esquina. Cuando el jugador intenta moverse en diagonal, puede ocurrir que:
La nueva posición completa (X + Y) está ocupada por una pared.
Pero la dirección solo en X o solo en Y está libre.
👉 En lugar de bloquear totalmente el movimiento, permitimos que el jugador se desplace parcialmente, generando una sensación más fluida y realista.
En nuestras funciones de movimiento (move_forward, move_backward, move_left y mode_right.), aplicamos la siguiente lógica:
if (valid(X + dx, Y + dy))
    mover completamente
else if (valid(X + dx, Y))
    mover solo en X
else if (valid(X, Y + dy))
    mover solo en Y
Esto permite:
Intentar moverse completamente.
Si no es posible, moverse en la dirección libre.
Si ambas están bloqueadas, quedarse quieto.
Sin sliding, chocar contra una pared en diagonal frena completamente al jugador, incluso si una de las dos direcciones está libre. 
Esto genera un comportamiento tosco o poco natural.
Con sliding, el jugador resbala por la pared, permitiendo un movimiento más suave y menos frustrante.

14.10.25 14h

Implementación de la rotación de la cámara con el ratón:
Implementamos rotación de la cámara con el ratón. Creamos una función que detecta el movimiento 
horizontal del cursor (xpos) y, si se mueve hacia la derecha o izquierda, actualiza la dirección del jugador llamando a rotate_player(). 
Además, centramos el ratón constantemente para evitar que llegue al borde de la ventana y poder seguir girando indefinidamente, como en los 
juegos en primera persona. Esta función se engancha con mlx_set_cursor_hook() de MLX42, y ocultamos el cursor con mlx_set_cursor_mode().
1. Detecta movimiento del ratón
MLX42 llama automáticamente a handle_mouse_movement() cada vez que el ratón se mueve.
Recibe las coordenadas del ratón: xpos (horizontal) y ypos (vertical).
🔄 2. Compara la posición actual con la anterior
delta_x = xpos - last_x calcula cuánto se ha movido el ratón horizontalmente.
Un valor positivo significa que el ratón se movió a la derecha, y negativo a la izquierda.
🔁 3. Gira al jugador
Si el ratón se movió a la derecha, se llama a rotate_player() con RIGHT.
Si se movió a la izquierda, se llama con LEFT.
Esta función actualiza la dirección (dir_x, dir_y) del jugador.
🎯 4. Centra el ratón
Se llama a mlx_set_mouse_pos() para volver a poner el ratón en el centro de la ventana.
Esto permite que el usuario pueda seguir girando indefinidamente, sin que el ratón llegue a los bordes de la pantalla.

Norminette (14.10.25 15h)
src/controls/events.c
- falta el header

está todo revisado salvo minimap, sprite y el main



src/
│
├── controls/
│   ├── events.c    // handle_keypress() y handle_close()
│
├── engines /
│   ├── collision.c //check_corners(), is_valid_pos()
│   ├── moves.c // rotate_player(), move_right(), move_left()...
│   └── player.c // update_player(), init_player_orientation()
│   └── raycasting.c //cast_all_rays(), calc_wall_dist(), perform_dda(), calc_step_dist(), init_ray()
│
├── graphics /
│   ├── draw_3d.c //get_tex_color(), get_tex_index(), calc_tex_x(), draw_floor_ceiling(), draw_tex_wall(), draw_column(), draw_3d_view()
│   ├── init_mlx.c//init_graphics.c(), load_textures(), load_texture()
│
├── minimap /
│   ├── minimap_cast.c //cast_ray_minimap(), cast_all_rays_minimap(), draw_rays(), draw_line(), 
│   ├── minimap_draw.c//draw_minimap(), draw_minimap_grid(), draw_player(), 
│   └── minimap_utils.c //init_minimap(), draw_square(), get_minimap_cell_color(), clear_minimap() 
│  
├── parsing /
│   ├──config_parser.c //parse_config(), handle_config_line(), extract_texture_path(), extract_color_raw()
│   ├── config_validator.c//validate_config(), validate_texture_path(), validate_color_str(), validate_rgb_values(), rgb_to_int()
|   ├── map_parser.c//parse_map(), count_rows()
|   ├── map_validator.c//validate_map(), check_trailing_rows(), is_map_closed(), normalize_map(), process_map_line(), measure_map(), 
|   ├── parser_utils.c //skip_empty_lines(), is_map_start_line()
│   └── read_file.c //load_info(), read_file(), count_file_lines()
├── utils /
│   ├── cleanup.c //cleanup_game(), free_map(), free_info(), free_str_array()
│   └── error.c //error_msg(), error_exit(), error_cleanup_exit()
└── main.c
└── init_structs.c

